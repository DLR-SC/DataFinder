#!/usr/bin/env python

#
# Generated Mon May 10 11:18:10 2010 by generateDS.py version 1.20e.
#

import sys
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class datastores(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, stores=None):
        if stores is None:
            self.stores = []
        else:
            self.stores = stores
    def factory(*args_, **kwargs_):
        if datastores.subclass:
            return datastores.subclass(*args_, **kwargs_)
        else:
            return datastores(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStores(self): return self.stores
    def setStores(self, stores): self.stores = stores
    def addStores(self, value): self.stores.append(value)
    def insertStores(self, index, value): self.stores[index] = value
    storesProp = property(getStores, setStores)
    def export(self, outfile, level, namespace_='', name_='datastores', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='datastores')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='datastores'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='datastores'):
        for stores_ in self.getStores():
            stores_.export(outfile, level, namespace_, name_='stores')
    def hasContent_(self):
        if (
            self.stores
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='datastores'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('stores=[\n')
        level += 1
        for stores_ in self.stores:
            showIndent(outfile, level)
            outfile.write('model_.datastore(\n')
            stores_.exportLiteral(outfile, level, name_='datastore')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'stores':
            type_name = child_.attributes.getNamedItemNS(
                'http://www.w3.org/2001/XMLSchema-instance', 'type')
            if type_name is not None:
                class_ = globals()[type_name.value]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <stores> element')
            self.stores.append(obj_)
# end class datastores


class datastore(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner=''):
        self.name = name
        self.storeType = storeType
        self.iconName = iconName
        self.url = url
        self.isDefault = isDefault
        self.owner = owner
    def factory(*args_, **kwargs_):
        if datastore.subclass:
            return datastore.subclass(*args_, **kwargs_)
        else:
            return datastore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    nameProp = property(getName, setName)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def getIconname(self): return self.iconName
    def setIconname(self, iconName): self.iconName = iconName
    iconNameProp = property(getIconname, setIconname)
    def getUrl(self): return self.url
    def setUrl(self, url): self.url = url
    urlProp = property(getUrl, setUrl)
    def getIsdefault(self): return self.isDefault
    def setIsdefault(self, isDefault): self.isDefault = isDefault
    isDefaultProp = property(getIsdefault, setIsdefault)
    def getOwner(self): return self.owner
    def setOwner(self, owner): self.owner = owner
    ownerProp = property(getOwner, setOwner)
    def export(self, outfile, level, namespace_='', name_='datastore', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='datastore')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='datastore'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='datastore'):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
        if self.iconName is not None:
            showIndent(outfile, level)
            outfile.write('<%siconName>%s</%siconName>\n' % (namespace_, self.format_string(quote_xml(self.iconName).encode(ExternalEncoding), input_name='iconName'), namespace_))
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('<%surl>%s</%surl>\n' % (namespace_, self.format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_))
        if self.isDefault is not None:
            showIndent(outfile, level)
            outfile.write('<%sisDefault>%s</%sisDefault>\n' % (namespace_, self.format_boolean(str_lower(str(self.isDefault)), input_name='isDefault'), namespace_))
        if self.owner is not None:
            showIndent(outfile, level)
            outfile.write('<%sowner>%s</%sowner>\n' % (namespace_, self.format_string(quote_xml(self.owner).encode(ExternalEncoding), input_name='owner'), namespace_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.storeType is not None or
            self.iconName is not None or
            self.url is not None or
            self.isDefault is not None or
            self.owner is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='datastore'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
        if self.iconName is not None:
            showIndent(outfile, level)
            outfile.write('iconName=%s,\n' % quote_python(self.iconName).encode(ExternalEncoding))
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
        if self.isDefault is not None:
            showIndent(outfile, level)
            outfile.write('isDefault=%s,\n' % self.isDefault)
        if self.owner is not None:
            showIndent(outfile, level)
            outfile.write('owner=%s,\n' % quote_python(self.owner).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'name':
            name_ = ''
            for text__content_ in child_.childNodes:
                name_ += text__content_.nodeValue
            self.name = name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'iconName':
            iconName_ = ''
            for text__content_ in child_.childNodes:
                iconName_ += text__content_.nodeValue
            self.iconName = iconName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'url':
            url_ = ''
            for text__content_ in child_.childNodes:
                url_ += text__content_.nodeValue
            self.url = url_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'isDefault':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.isDefault = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'owner':
            owner_ = ''
            for text__content_ in child_.childNodes:
                owner_ += text__content_.nodeValue
            self.owner = owner_
# end class datastore


class default(datastore):
    subclass = None
    superclass = datastore
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner=''):
        datastore.__init__(self, name, storeType, iconName, url, isDefault, owner)
        self.storeType = storeType
    def factory(*args_, **kwargs_):
        if default.subclass:
            return default.subclass(*args_, **kwargs_)
        else:
            return default(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def export(self, outfile, level, namespace_='', name_='default', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='default')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="default"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='default'):
        datastore.exportAttributes(self, outfile, level, namespace_, name_='default')
    def exportChildren(self, outfile, level, namespace_='', name_='default'):
        datastore.exportChildren(self, outfile, level, namespace_, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
    def hasContent_(self):
        if (
            self.storeType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='default'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        datastore.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        datastore.exportLiteralChildren(self, outfile, level, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        datastore.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        datastore.buildChildren(self, child_, nodeName_)
# end class default


class file(datastore):
    subclass = None
    superclass = datastore
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner='', dataLocation='', removePathPrefix='', isMigratedTo='', storageRealisation='Hierarchical', username='', password=''):
        datastore.__init__(self, name, storeType, iconName, url, isDefault, owner)
        self.storeType = storeType
        self.dataLocation = dataLocation
        self.removePathPrefix = removePathPrefix
        self.isMigratedTo = isMigratedTo
        self.storageRealisation = storageRealisation
        self.username = username
        self.password = password
    def factory(*args_, **kwargs_):
        if file.subclass:
            return file.subclass(*args_, **kwargs_)
        else:
            return file(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def getDatalocation(self): return self.dataLocation
    def setDatalocation(self, dataLocation): self.dataLocation = dataLocation
    dataLocationProp = property(getDatalocation, setDatalocation)
    def getRemovepathprefix(self): return self.removePathPrefix
    def setRemovepathprefix(self, removePathPrefix): self.removePathPrefix = removePathPrefix
    removePathPrefixProp = property(getRemovepathprefix, setRemovepathprefix)
    def getIsmigratedto(self): return self.isMigratedTo
    def setIsmigratedto(self, isMigratedTo): self.isMigratedTo = isMigratedTo
    isMigratedToProp = property(getIsmigratedto, setIsmigratedto)
    def getStoragerealisation(self): return self.storageRealisation
    def setStoragerealisation(self, storageRealisation): self.storageRealisation = storageRealisation
    storageRealisationProp = property(getStoragerealisation, setStoragerealisation)
    def validate_storageRealisation(self, value):
        # validate type storageRealisation
        pass
    def getUsername(self): return self.username
    def setUsername(self, username): self.username = username
    usernameProp = property(getUsername, setUsername)
    def getPassword(self): return self.password
    def setPassword(self, password): self.password = password
    passwordProp = property(getPassword, setPassword)
    def export(self, outfile, level, namespace_='', name_='file', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='file')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="file"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='file'):
        datastore.exportAttributes(self, outfile, level, namespace_, name_='file')
    def exportChildren(self, outfile, level, namespace_='', name_='file'):
        datastore.exportChildren(self, outfile, level, namespace_, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataLocation>%s</%sdataLocation>\n' % (namespace_, self.format_string(quote_xml(self.dataLocation).encode(ExternalEncoding), input_name='dataLocation'), namespace_))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('<%sremovePathPrefix>%s</%sremovePathPrefix>\n' % (namespace_, self.format_string(quote_xml(self.removePathPrefix).encode(ExternalEncoding), input_name='removePathPrefix'), namespace_))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('<%sisMigratedTo>%s</%sisMigratedTo>\n' % (namespace_, self.format_string(quote_xml(self.isMigratedTo).encode(ExternalEncoding), input_name='isMigratedTo'), namespace_))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageRealisation>%s</%sstorageRealisation>\n' % (namespace_, self.format_string(quote_xml(self.storageRealisation).encode(ExternalEncoding), input_name='storageRealisation'), namespace_))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('<%susername>%s</%susername>\n' % (namespace_, self.format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('<%spassword>%s</%spassword>\n' % (namespace_, self.format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_))
    def hasContent_(self):
        if (
            self.storeType is not None or
            self.dataLocation is not None or
            self.removePathPrefix is not None or
            self.isMigratedTo is not None or
            self.storageRealisation is not None or
            self.username is not None or
            self.password is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        datastore.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        datastore.exportLiteralChildren(self, outfile, level, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('dataLocation=%s,\n' % quote_python(self.dataLocation).encode(ExternalEncoding))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('removePathPrefix=%s,\n' % quote_python(self.removePathPrefix).encode(ExternalEncoding))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('isMigratedTo=%s,\n' % quote_python(self.isMigratedTo).encode(ExternalEncoding))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('storageRealisation=%s,\n' % quote_python(self.storageRealisation).encode(ExternalEncoding))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        datastore.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataLocation':
            dataLocation_ = ''
            for text__content_ in child_.childNodes:
                dataLocation_ += text__content_.nodeValue
            self.dataLocation = dataLocation_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'removePathPrefix':
            removePathPrefix_ = ''
            for text__content_ in child_.childNodes:
                removePathPrefix_ += text__content_.nodeValue
            self.removePathPrefix = removePathPrefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'isMigratedTo':
            isMigratedTo_ = ''
            for text__content_ in child_.childNodes:
                isMigratedTo_ += text__content_.nodeValue
            self.isMigratedTo = isMigratedTo_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storageRealisation':
            storageRealisation_ = ''
            for text__content_ in child_.childNodes:
                storageRealisation_ += text__content_.nodeValue
            self.storageRealisation = storageRealisation_
            self.validate_storageRealisation(self.storageRealisation)    # validate type storageRealisation
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'username':
            username_ = ''
            for text__content_ in child_.childNodes:
                username_ += text__content_.nodeValue
            self.username = username_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'password':
            password_ = ''
            for text__content_ in child_.childNodes:
                password_ += text__content_.nodeValue
            self.password = password_
        datastore.buildChildren(self, child_, nodeName_)
# end class file


class ftp(datastore):
    subclass = None
    superclass = datastore
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner='', dataLocation='', removePathPrefix='', isMigratedTo='', storageRealisation='Hierarchical', username='', password='', isAnonymousAuthenticationEnabled=True):
        datastore.__init__(self, name, storeType, iconName, url, isDefault, owner)
        self.storeType = storeType
        self.dataLocation = dataLocation
        self.removePathPrefix = removePathPrefix
        self.isMigratedTo = isMigratedTo
        self.storageRealisation = storageRealisation
        self.username = username
        self.password = password
        self.isAnonymousAuthenticationEnabled = isAnonymousAuthenticationEnabled
    def factory(*args_, **kwargs_):
        if ftp.subclass:
            return ftp.subclass(*args_, **kwargs_)
        else:
            return ftp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def getDatalocation(self): return self.dataLocation
    def setDatalocation(self, dataLocation): self.dataLocation = dataLocation
    dataLocationProp = property(getDatalocation, setDatalocation)
    def getRemovepathprefix(self): return self.removePathPrefix
    def setRemovepathprefix(self, removePathPrefix): self.removePathPrefix = removePathPrefix
    removePathPrefixProp = property(getRemovepathprefix, setRemovepathprefix)
    def getIsmigratedto(self): return self.isMigratedTo
    def setIsmigratedto(self, isMigratedTo): self.isMigratedTo = isMigratedTo
    isMigratedToProp = property(getIsmigratedto, setIsmigratedto)
    def getStoragerealisation(self): return self.storageRealisation
    def setStoragerealisation(self, storageRealisation): self.storageRealisation = storageRealisation
    storageRealisationProp = property(getStoragerealisation, setStoragerealisation)
    def validate_storageRealisation(self, value):
        # validate type storageRealisation
        pass
    def getUsername(self): return self.username
    def setUsername(self, username): self.username = username
    usernameProp = property(getUsername, setUsername)
    def getPassword(self): return self.password
    def setPassword(self, password): self.password = password
    passwordProp = property(getPassword, setPassword)
    def getIsanonymousauthenticationenabled(self): return self.isAnonymousAuthenticationEnabled
    def setIsanonymousauthenticationenabled(self, isAnonymousAuthenticationEnabled): self.isAnonymousAuthenticationEnabled = isAnonymousAuthenticationEnabled
    isAnonymousAuthenticationEnabledProp = property(getIsanonymousauthenticationenabled, setIsanonymousauthenticationenabled)
    def export(self, outfile, level, namespace_='', name_='ftp', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ftp')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="ftp"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ftp'):
        datastore.exportAttributes(self, outfile, level, namespace_, name_='ftp')
    def exportChildren(self, outfile, level, namespace_='', name_='ftp'):
        datastore.exportChildren(self, outfile, level, namespace_, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataLocation>%s</%sdataLocation>\n' % (namespace_, self.format_string(quote_xml(self.dataLocation).encode(ExternalEncoding), input_name='dataLocation'), namespace_))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('<%sremovePathPrefix>%s</%sremovePathPrefix>\n' % (namespace_, self.format_string(quote_xml(self.removePathPrefix).encode(ExternalEncoding), input_name='removePathPrefix'), namespace_))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('<%sisMigratedTo>%s</%sisMigratedTo>\n' % (namespace_, self.format_string(quote_xml(self.isMigratedTo).encode(ExternalEncoding), input_name='isMigratedTo'), namespace_))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageRealisation>%s</%sstorageRealisation>\n' % (namespace_, self.format_string(quote_xml(self.storageRealisation).encode(ExternalEncoding), input_name='storageRealisation'), namespace_))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('<%susername>%s</%susername>\n' % (namespace_, self.format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('<%spassword>%s</%spassword>\n' % (namespace_, self.format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_))
        if self.isAnonymousAuthenticationEnabled is not None:
            showIndent(outfile, level)
            outfile.write('<%sisAnonymousAuthenticationEnabled>%s</%sisAnonymousAuthenticationEnabled>\n' % (namespace_, self.format_boolean(str_lower(str(self.isAnonymousAuthenticationEnabled)), input_name='isAnonymousAuthenticationEnabled'), namespace_))
    def hasContent_(self):
        if (
            self.storeType is not None or
            self.dataLocation is not None or
            self.removePathPrefix is not None or
            self.isMigratedTo is not None or
            self.storageRealisation is not None or
            self.username is not None or
            self.password is not None or
            self.isAnonymousAuthenticationEnabled is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ftp'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        datastore.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        datastore.exportLiteralChildren(self, outfile, level, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('dataLocation=%s,\n' % quote_python(self.dataLocation).encode(ExternalEncoding))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('removePathPrefix=%s,\n' % quote_python(self.removePathPrefix).encode(ExternalEncoding))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('isMigratedTo=%s,\n' % quote_python(self.isMigratedTo).encode(ExternalEncoding))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('storageRealisation=%s,\n' % quote_python(self.storageRealisation).encode(ExternalEncoding))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
        if self.isAnonymousAuthenticationEnabled is not None:
            showIndent(outfile, level)
            outfile.write('isAnonymousAuthenticationEnabled=%s,\n' % self.isAnonymousAuthenticationEnabled)
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        datastore.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataLocation':
            dataLocation_ = ''
            for text__content_ in child_.childNodes:
                dataLocation_ += text__content_.nodeValue
            self.dataLocation = dataLocation_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'removePathPrefix':
            removePathPrefix_ = ''
            for text__content_ in child_.childNodes:
                removePathPrefix_ += text__content_.nodeValue
            self.removePathPrefix = removePathPrefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'isMigratedTo':
            isMigratedTo_ = ''
            for text__content_ in child_.childNodes:
                isMigratedTo_ += text__content_.nodeValue
            self.isMigratedTo = isMigratedTo_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storageRealisation':
            storageRealisation_ = ''
            for text__content_ in child_.childNodes:
                storageRealisation_ += text__content_.nodeValue
            self.storageRealisation = storageRealisation_
            self.validate_storageRealisation(self.storageRealisation)    # validate type storageRealisation
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'username':
            username_ = ''
            for text__content_ in child_.childNodes:
                username_ += text__content_.nodeValue
            self.username = username_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'password':
            password_ = ''
            for text__content_ in child_.childNodes:
                password_ += text__content_.nodeValue
            self.password = password_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'isAnonymousAuthenticationEnabled':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.isAnonymousAuthenticationEnabled = ival_
        datastore.buildChildren(self, child_, nodeName_)
# end class ftp


class gridftp(datastore):
    subclass = None
    superclass = datastore
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner='', dataLocation='', removePathPrefix='', isMigratedTo='', storageRealisation='Hierarchical', securityMode='Standard', dataTransferMode='Stream', tcpBufferSize=60, parallelConnections=1):
        datastore.__init__(self, name, storeType, iconName, url, isDefault, owner)
        self.storeType = storeType
        self.dataLocation = dataLocation
        self.removePathPrefix = removePathPrefix
        self.isMigratedTo = isMigratedTo
        self.storageRealisation = storageRealisation
        self.securityMode = securityMode
        self.dataTransferMode = dataTransferMode
        self.tcpBufferSize = tcpBufferSize
        self.parallelConnections = parallelConnections
    def factory(*args_, **kwargs_):
        if gridftp.subclass:
            return gridftp.subclass(*args_, **kwargs_)
        else:
            return gridftp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def getDatalocation(self): return self.dataLocation
    def setDatalocation(self, dataLocation): self.dataLocation = dataLocation
    dataLocationProp = property(getDatalocation, setDatalocation)
    def getRemovepathprefix(self): return self.removePathPrefix
    def setRemovepathprefix(self, removePathPrefix): self.removePathPrefix = removePathPrefix
    removePathPrefixProp = property(getRemovepathprefix, setRemovepathprefix)
    def getIsmigratedto(self): return self.isMigratedTo
    def setIsmigratedto(self, isMigratedTo): self.isMigratedTo = isMigratedTo
    isMigratedToProp = property(getIsmigratedto, setIsmigratedto)
    def getStoragerealisation(self): return self.storageRealisation
    def setStoragerealisation(self, storageRealisation): self.storageRealisation = storageRealisation
    storageRealisationProp = property(getStoragerealisation, setStoragerealisation)
    def validate_storageRealisation(self, value):
        # validate type storageRealisation
        pass
    def getSecuritymode(self): return self.securityMode
    def setSecuritymode(self, securityMode): self.securityMode = securityMode
    securityModeProp = property(getSecuritymode, setSecuritymode)
    def validate_securityMode(self, value):
        # Validate type securityMode, a restriction on xs:NMTOKEN.
        pass
    def getDatatransfermode(self): return self.dataTransferMode
    def setDatatransfermode(self, dataTransferMode): self.dataTransferMode = dataTransferMode
    dataTransferModeProp = property(getDatatransfermode, setDatatransfermode)
    def validate_dataTransferMode(self, value):
        # Validate type dataTransferMode, a restriction on xs:NMTOKEN.
        pass
    def getTcpbuffersize(self): return self.tcpBufferSize
    def setTcpbuffersize(self, tcpBufferSize): self.tcpBufferSize = tcpBufferSize
    tcpBufferSizeProp = property(getTcpbuffersize, setTcpbuffersize)
    def getParallelconnections(self): return self.parallelConnections
    def setParallelconnections(self, parallelConnections): self.parallelConnections = parallelConnections
    parallelConnectionsProp = property(getParallelconnections, setParallelconnections)
    def export(self, outfile, level, namespace_='', name_='gridftp', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='gridftp')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="gridftp"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='gridftp'):
        datastore.exportAttributes(self, outfile, level, namespace_, name_='gridftp')
    def exportChildren(self, outfile, level, namespace_='', name_='gridftp'):
        datastore.exportChildren(self, outfile, level, namespace_, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataLocation>%s</%sdataLocation>\n' % (namespace_, self.format_string(quote_xml(self.dataLocation).encode(ExternalEncoding), input_name='dataLocation'), namespace_))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('<%sremovePathPrefix>%s</%sremovePathPrefix>\n' % (namespace_, self.format_string(quote_xml(self.removePathPrefix).encode(ExternalEncoding), input_name='removePathPrefix'), namespace_))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('<%sisMigratedTo>%s</%sisMigratedTo>\n' % (namespace_, self.format_string(quote_xml(self.isMigratedTo).encode(ExternalEncoding), input_name='isMigratedTo'), namespace_))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageRealisation>%s</%sstorageRealisation>\n' % (namespace_, self.format_string(quote_xml(self.storageRealisation).encode(ExternalEncoding), input_name='storageRealisation'), namespace_))
        if self.securityMode is not None:
            showIndent(outfile, level)
            outfile.write('<%ssecurityMode>%s</%ssecurityMode>\n' % (namespace_, self.format_string(quote_xml(self.securityMode).encode(ExternalEncoding), input_name='securityMode'), namespace_))
        if self.dataTransferMode is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataTransferMode>%s</%sdataTransferMode>\n' % (namespace_, self.format_string(quote_xml(self.dataTransferMode).encode(ExternalEncoding), input_name='dataTransferMode'), namespace_))
        if self.tcpBufferSize is not None:
            showIndent(outfile, level)
            outfile.write('<%stcpBufferSize>%s</%stcpBufferSize>\n' % (namespace_, self.format_integer(self.tcpBufferSize, input_name='tcpBufferSize'), namespace_))
        if self.parallelConnections is not None:
            showIndent(outfile, level)
            outfile.write('<%sparallelConnections>%s</%sparallelConnections>\n' % (namespace_, self.format_integer(self.parallelConnections, input_name='parallelConnections'), namespace_))
    def hasContent_(self):
        if (
            self.storeType is not None or
            self.dataLocation is not None or
            self.removePathPrefix is not None or
            self.isMigratedTo is not None or
            self.storageRealisation is not None or
            self.securityMode is not None or
            self.dataTransferMode is not None or
            self.tcpBufferSize is not None or
            self.parallelConnections is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gridftp'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        datastore.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        datastore.exportLiteralChildren(self, outfile, level, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('dataLocation=%s,\n' % quote_python(self.dataLocation).encode(ExternalEncoding))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('removePathPrefix=%s,\n' % quote_python(self.removePathPrefix).encode(ExternalEncoding))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('isMigratedTo=%s,\n' % quote_python(self.isMigratedTo).encode(ExternalEncoding))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('storageRealisation=%s,\n' % quote_python(self.storageRealisation).encode(ExternalEncoding))
        if self.securityMode is not None:
            showIndent(outfile, level)
            outfile.write('securityMode=%s,\n' % quote_python(self.securityMode).encode(ExternalEncoding))
        if self.dataTransferMode is not None:
            showIndent(outfile, level)
            outfile.write('dataTransferMode=%s,\n' % quote_python(self.dataTransferMode).encode(ExternalEncoding))
        if self.tcpBufferSize is not None:
            showIndent(outfile, level)
            outfile.write('tcpBufferSize=%d,\n' % self.tcpBufferSize)
        if self.parallelConnections is not None:
            showIndent(outfile, level)
            outfile.write('parallelConnections=%d,\n' % self.parallelConnections)
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        datastore.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataLocation':
            dataLocation_ = ''
            for text__content_ in child_.childNodes:
                dataLocation_ += text__content_.nodeValue
            self.dataLocation = dataLocation_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'removePathPrefix':
            removePathPrefix_ = ''
            for text__content_ in child_.childNodes:
                removePathPrefix_ += text__content_.nodeValue
            self.removePathPrefix = removePathPrefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'isMigratedTo':
            isMigratedTo_ = ''
            for text__content_ in child_.childNodes:
                isMigratedTo_ += text__content_.nodeValue
            self.isMigratedTo = isMigratedTo_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storageRealisation':
            storageRealisation_ = ''
            for text__content_ in child_.childNodes:
                storageRealisation_ += text__content_.nodeValue
            self.storageRealisation = storageRealisation_
            self.validate_storageRealisation(self.storageRealisation)    # validate type storageRealisation
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'securityMode':
            securityMode_ = ''
            for text__content_ in child_.childNodes:
                securityMode_ += text__content_.nodeValue
            self.securityMode = securityMode_
            self.validate_securityMode(self.securityMode)    # validate type securityMode
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataTransferMode':
            dataTransferMode_ = ''
            for text__content_ in child_.childNodes:
                dataTransferMode_ += text__content_.nodeValue
            self.dataTransferMode = dataTransferMode_
            self.validate_dataTransferMode(self.dataTransferMode)    # validate type dataTransferMode
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'tcpBufferSize':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (tcpBufferSize): %s' % exp)
                if ival_ <= 0:
                    raise ValueError('requires positiveInteger -- %s' % child_.toxml())
                self.tcpBufferSize = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'parallelConnections':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (parallelConnections): %s' % exp)
                if ival_ <= 0:
                    raise ValueError('requires positiveInteger -- %s' % child_.toxml())
                self.parallelConnections = ival_
        datastore.buildChildren(self, child_, nodeName_)
# end class gridftp


class securityMode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if securityMode.subclass:
            return securityMode.subclass(*args_, **kwargs_)
        else:
            return securityMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='securityMode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='securityMode')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='securityMode'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='securityMode'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='securityMode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class securityMode


class dataTransferMode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dataTransferMode.subclass:
            return dataTransferMode.subclass(*args_, **kwargs_)
        else:
            return dataTransferMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='dataTransferMode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dataTransferMode')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='dataTransferMode'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dataTransferMode'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dataTransferMode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class dataTransferMode


class offlinemedia(datastore):
    subclass = None
    superclass = datastore
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner='', dataLocation=''):
        datastore.__init__(self, name, storeType, iconName, url, isDefault, owner)
        self.storeType = storeType
        self.dataLocation = dataLocation
    def factory(*args_, **kwargs_):
        if offlinemedia.subclass:
            return offlinemedia.subclass(*args_, **kwargs_)
        else:
            return offlinemedia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def getDatalocation(self): return self.dataLocation
    def setDatalocation(self, dataLocation): self.dataLocation = dataLocation
    dataLocationProp = property(getDatalocation, setDatalocation)
    def export(self, outfile, level, namespace_='', name_='offlinemedia', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='offlinemedia')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="offlinemedia"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='offlinemedia'):
        datastore.exportAttributes(self, outfile, level, namespace_, name_='offlinemedia')
    def exportChildren(self, outfile, level, namespace_='', name_='offlinemedia'):
        datastore.exportChildren(self, outfile, level, namespace_, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataLocation>%s</%sdataLocation>\n' % (namespace_, self.format_string(quote_xml(self.dataLocation).encode(ExternalEncoding), input_name='dataLocation'), namespace_))
    def hasContent_(self):
        if (
            self.storeType is not None or
            self.dataLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='offlinemedia'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        datastore.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        datastore.exportLiteralChildren(self, outfile, level, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('dataLocation=%s,\n' % quote_python(self.dataLocation).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        datastore.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataLocation':
            dataLocation_ = ''
            for text__content_ in child_.childNodes:
                dataLocation_ += text__content_.nodeValue
            self.dataLocation = dataLocation_
        datastore.buildChildren(self, child_, nodeName_)
# end class offlinemedia


class tsm(datastore):
    subclass = None
    superclass = datastore
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner='', clientHostName='', serverNodeName='', archiveRootDirectory='', description='', retentionPeriod=0, readOnly=False, username='', password='', storageRealisation='Flat', isMigratedTo=''):
        datastore.__init__(self, name, storeType, iconName, url, isDefault, owner)
        self.storeType = storeType
        self.clientHostName = clientHostName
        self.serverNodeName = serverNodeName
        self.archiveRootDirectory = archiveRootDirectory
        self.description = description
        self.retentionPeriod = retentionPeriod
        self.readOnly = readOnly
        self.username = username
        self.password = password
        self.storageRealisation = storageRealisation
        self.isMigratedTo = isMigratedTo
    def factory(*args_, **kwargs_):
        if tsm.subclass:
            return tsm.subclass(*args_, **kwargs_)
        else:
            return tsm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def getClienthostname(self): return self.clientHostName
    def setClienthostname(self, clientHostName): self.clientHostName = clientHostName
    clientHostNameProp = property(getClienthostname, setClienthostname)
    def getServernodename(self): return self.serverNodeName
    def setServernodename(self, serverNodeName): self.serverNodeName = serverNodeName
    serverNodeNameProp = property(getServernodename, setServernodename)
    def getArchiverootdirectory(self): return self.archiveRootDirectory
    def setArchiverootdirectory(self, archiveRootDirectory): self.archiveRootDirectory = archiveRootDirectory
    archiveRootDirectoryProp = property(getArchiverootdirectory, setArchiverootdirectory)
    def getDescription(self): return self.description
    def setDescription(self, description): self.description = description
    descriptionProp = property(getDescription, setDescription)
    def getRetentionperiod(self): return self.retentionPeriod
    def setRetentionperiod(self, retentionPeriod): self.retentionPeriod = retentionPeriod
    retentionPeriodProp = property(getRetentionperiod, setRetentionperiod)
    def getReadonly(self): return self.readOnly
    def setReadonly(self, readOnly): self.readOnly = readOnly
    readOnlyProp = property(getReadonly, setReadonly)
    def getUsername(self): return self.username
    def setUsername(self, username): self.username = username
    usernameProp = property(getUsername, setUsername)
    def getPassword(self): return self.password
    def setPassword(self, password): self.password = password
    passwordProp = property(getPassword, setPassword)
    def getStoragerealisation(self): return self.storageRealisation
    def setStoragerealisation(self, storageRealisation): self.storageRealisation = storageRealisation
    storageRealisationProp = property(getStoragerealisation, setStoragerealisation)
    def validate_storageRealisation(self, value):
        # validate type storageRealisation
        pass
    def getIsmigratedto(self): return self.isMigratedTo
    def setIsmigratedto(self, isMigratedTo): self.isMigratedTo = isMigratedTo
    isMigratedToProp = property(getIsmigratedto, setIsmigratedto)
    def export(self, outfile, level, namespace_='', name_='tsm', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='tsm')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="tsm"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='tsm'):
        datastore.exportAttributes(self, outfile, level, namespace_, name_='tsm')
    def exportChildren(self, outfile, level, namespace_='', name_='tsm'):
        datastore.exportChildren(self, outfile, level, namespace_, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
        if self.clientHostName is not None:
            showIndent(outfile, level)
            outfile.write('<%sclientHostName>%s</%sclientHostName>\n' % (namespace_, self.format_string(quote_xml(self.clientHostName).encode(ExternalEncoding), input_name='clientHostName'), namespace_))
        if self.serverNodeName is not None:
            showIndent(outfile, level)
            outfile.write('<%sserverNodeName>%s</%sserverNodeName>\n' % (namespace_, self.format_string(quote_xml(self.serverNodeName).encode(ExternalEncoding), input_name='serverNodeName'), namespace_))
        if self.archiveRootDirectory is not None:
            showIndent(outfile, level)
            outfile.write('<%sarchiveRootDirectory>%s</%sarchiveRootDirectory>\n' % (namespace_, self.format_string(quote_xml(self.archiveRootDirectory).encode(ExternalEncoding), input_name='archiveRootDirectory'), namespace_))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.retentionPeriod is not None:
            showIndent(outfile, level)
            outfile.write('<%sretentionPeriod>%s</%sretentionPeriod>\n' % (namespace_, self.format_integer(self.retentionPeriod, input_name='retentionPeriod'), namespace_))
        if self.readOnly is not None:
            showIndent(outfile, level)
            outfile.write('<%sreadOnly>%s</%sreadOnly>\n' % (namespace_, self.format_boolean(str_lower(str(self.readOnly)), input_name='readOnly'), namespace_))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('<%susername>%s</%susername>\n' % (namespace_, self.format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('<%spassword>%s</%spassword>\n' % (namespace_, self.format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageRealisation>%s</%sstorageRealisation>\n' % (namespace_, self.format_string(quote_xml(self.storageRealisation).encode(ExternalEncoding), input_name='storageRealisation'), namespace_))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('<%sisMigratedTo>%s</%sisMigratedTo>\n' % (namespace_, self.format_string(quote_xml(self.isMigratedTo).encode(ExternalEncoding), input_name='isMigratedTo'), namespace_))
    def hasContent_(self):
        if (
            self.storeType is not None or
            self.clientHostName is not None or
            self.serverNodeName is not None or
            self.archiveRootDirectory is not None or
            self.description is not None or
            self.retentionPeriod is not None or
            self.readOnly is not None or
            self.username is not None or
            self.password is not None or
            self.storageRealisation is not None or
            self.isMigratedTo is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='tsm'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        datastore.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        datastore.exportLiteralChildren(self, outfile, level, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
        if self.clientHostName is not None:
            showIndent(outfile, level)
            outfile.write('clientHostName=%s,\n' % quote_python(self.clientHostName).encode(ExternalEncoding))
        if self.serverNodeName is not None:
            showIndent(outfile, level)
            outfile.write('serverNodeName=%s,\n' % quote_python(self.serverNodeName).encode(ExternalEncoding))
        if self.archiveRootDirectory is not None:
            showIndent(outfile, level)
            outfile.write('archiveRootDirectory=%s,\n' % quote_python(self.archiveRootDirectory).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.retentionPeriod is not None:
            showIndent(outfile, level)
            outfile.write('retentionPeriod=%d,\n' % self.retentionPeriod)
        if self.readOnly is not None:
            showIndent(outfile, level)
            outfile.write('readOnly=%s,\n' % self.readOnly)
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('storageRealisation=%s,\n' % quote_python(self.storageRealisation).encode(ExternalEncoding))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('isMigratedTo=%s,\n' % quote_python(self.isMigratedTo).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        datastore.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'clientHostName':
            clientHostName_ = ''
            for text__content_ in child_.childNodes:
                clientHostName_ += text__content_.nodeValue
            self.clientHostName = clientHostName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'serverNodeName':
            serverNodeName_ = ''
            for text__content_ in child_.childNodes:
                serverNodeName_ += text__content_.nodeValue
            self.serverNodeName = serverNodeName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'archiveRootDirectory':
            archiveRootDirectory_ = ''
            for text__content_ in child_.childNodes:
                archiveRootDirectory_ += text__content_.nodeValue
            self.archiveRootDirectory = archiveRootDirectory_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'retentionPeriod':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (retentionPeriod): %s' % exp)
                self.retentionPeriod = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'readOnly':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.readOnly = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'username':
            username_ = ''
            for text__content_ in child_.childNodes:
                username_ += text__content_.nodeValue
            self.username = username_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'password':
            password_ = ''
            for text__content_ in child_.childNodes:
                password_ += text__content_.nodeValue
            self.password = password_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storageRealisation':
            storageRealisation_ = ''
            for text__content_ in child_.childNodes:
                storageRealisation_ += text__content_.nodeValue
            self.storageRealisation = storageRealisation_
            self.validate_storageRealisation(self.storageRealisation)    # validate type storageRealisation
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'isMigratedTo':
            isMigratedTo_ = ''
            for text__content_ in child_.childNodes:
                isMigratedTo_ += text__content_.nodeValue
            self.isMigratedTo = isMigratedTo_
        datastore.buildChildren(self, child_, nodeName_)
# end class tsm


class webdav(datastore):
    subclass = None
    superclass = datastore
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner='', dataLocation='', removePathPrefix='', isMigratedTo='', storageRealisation='Hierarchical', username='', password=''):
        datastore.__init__(self, name, storeType, iconName, url, isDefault, owner)
        self.storeType = storeType
        self.dataLocation = dataLocation
        self.removePathPrefix = removePathPrefix
        self.isMigratedTo = isMigratedTo
        self.storageRealisation = storageRealisation
        self.username = username
        self.password = password
    def factory(*args_, **kwargs_):
        if webdav.subclass:
            return webdav.subclass(*args_, **kwargs_)
        else:
            return webdav(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def getDatalocation(self): return self.dataLocation
    def setDatalocation(self, dataLocation): self.dataLocation = dataLocation
    dataLocationProp = property(getDatalocation, setDatalocation)
    def getRemovepathprefix(self): return self.removePathPrefix
    def setRemovepathprefix(self, removePathPrefix): self.removePathPrefix = removePathPrefix
    removePathPrefixProp = property(getRemovepathprefix, setRemovepathprefix)
    def getIsmigratedto(self): return self.isMigratedTo
    def setIsmigratedto(self, isMigratedTo): self.isMigratedTo = isMigratedTo
    isMigratedToProp = property(getIsmigratedto, setIsmigratedto)
    def getStoragerealisation(self): return self.storageRealisation
    def setStoragerealisation(self, storageRealisation): self.storageRealisation = storageRealisation
    storageRealisationProp = property(getStoragerealisation, setStoragerealisation)
    def validate_storageRealisation(self, value):
        # validate type storageRealisation
        pass
    def getUsername(self): return self.username
    def setUsername(self, username): self.username = username
    usernameProp = property(getUsername, setUsername)
    def getPassword(self): return self.password
    def setPassword(self, password): self.password = password
    passwordProp = property(getPassword, setPassword)
    def export(self, outfile, level, namespace_='', name_='webdav', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='webdav')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="webdav"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='webdav'):
        datastore.exportAttributes(self, outfile, level, namespace_, name_='webdav')
    def exportChildren(self, outfile, level, namespace_='', name_='webdav'):
        datastore.exportChildren(self, outfile, level, namespace_, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataLocation>%s</%sdataLocation>\n' % (namespace_, self.format_string(quote_xml(self.dataLocation).encode(ExternalEncoding), input_name='dataLocation'), namespace_))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('<%sremovePathPrefix>%s</%sremovePathPrefix>\n' % (namespace_, self.format_string(quote_xml(self.removePathPrefix).encode(ExternalEncoding), input_name='removePathPrefix'), namespace_))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('<%sisMigratedTo>%s</%sisMigratedTo>\n' % (namespace_, self.format_string(quote_xml(self.isMigratedTo).encode(ExternalEncoding), input_name='isMigratedTo'), namespace_))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageRealisation>%s</%sstorageRealisation>\n' % (namespace_, self.format_string(quote_xml(self.storageRealisation).encode(ExternalEncoding), input_name='storageRealisation'), namespace_))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('<%susername>%s</%susername>\n' % (namespace_, self.format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('<%spassword>%s</%spassword>\n' % (namespace_, self.format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_))
    def hasContent_(self):
        if (
            self.storeType is not None or
            self.dataLocation is not None or
            self.removePathPrefix is not None or
            self.isMigratedTo is not None or
            self.storageRealisation is not None or
            self.username is not None or
            self.password is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='webdav'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        datastore.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        datastore.exportLiteralChildren(self, outfile, level, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('dataLocation=%s,\n' % quote_python(self.dataLocation).encode(ExternalEncoding))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('removePathPrefix=%s,\n' % quote_python(self.removePathPrefix).encode(ExternalEncoding))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('isMigratedTo=%s,\n' % quote_python(self.isMigratedTo).encode(ExternalEncoding))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('storageRealisation=%s,\n' % quote_python(self.storageRealisation).encode(ExternalEncoding))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        datastore.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataLocation':
            dataLocation_ = ''
            for text__content_ in child_.childNodes:
                dataLocation_ += text__content_.nodeValue
            self.dataLocation = dataLocation_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'removePathPrefix':
            removePathPrefix_ = ''
            for text__content_ in child_.childNodes:
                removePathPrefix_ += text__content_.nodeValue
            self.removePathPrefix = removePathPrefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'isMigratedTo':
            isMigratedTo_ = ''
            for text__content_ in child_.childNodes:
                isMigratedTo_ += text__content_.nodeValue
            self.isMigratedTo = isMigratedTo_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storageRealisation':
            storageRealisation_ = ''
            for text__content_ in child_.childNodes:
                storageRealisation_ += text__content_.nodeValue
            self.storageRealisation = storageRealisation_
            self.validate_storageRealisation(self.storageRealisation)    # validate type storageRealisation
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'username':
            username_ = ''
            for text__content_ in child_.childNodes:
                username_ += text__content_.nodeValue
            self.username = username_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'password':
            password_ = ''
            for text__content_ in child_.childNodes:
                password_ += text__content_.nodeValue
            self.password = password_
        datastore.buildChildren(self, child_, nodeName_)
# end class webdav


class s3(datastore):
    subclass = None
    superclass = datastore
    def __init__(self, name='', storeType=None, iconName='dataStore', url='', isDefault=False, owner='', dataLocation='', removePathPrefix='', isMigratedTo='', storageRealisation='Flat', username='', password='', awsAccessKey='', awsSecretAccessKey=''):
        datastore.__init__(self, name, storeType, iconName, url, isDefault, owner)
        self.storeType = storeType
        self.dataLocation = dataLocation
        self.removePathPrefix = removePathPrefix
        self.isMigratedTo = isMigratedTo
        self.storageRealisation = storageRealisation
        self.username = username
        self.password = password
        self.awsAccessKey = awsAccessKey
        self.awsSecretAccessKey = awsSecretAccessKey
    def factory(*args_, **kwargs_):
        if s3.subclass:
            return s3.subclass(*args_, **kwargs_)
        else:
            return s3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStoretype(self): return self.storeType
    def setStoretype(self, storeType): self.storeType = storeType
    storeTypeProp = property(getStoretype, setStoretype)
    def getDatalocation(self): return self.dataLocation
    def setDatalocation(self, dataLocation): self.dataLocation = dataLocation
    dataLocationProp = property(getDatalocation, setDatalocation)
    def getRemovepathprefix(self): return self.removePathPrefix
    def setRemovepathprefix(self, removePathPrefix): self.removePathPrefix = removePathPrefix
    removePathPrefixProp = property(getRemovepathprefix, setRemovepathprefix)
    def getIsmigratedto(self): return self.isMigratedTo
    def setIsmigratedto(self, isMigratedTo): self.isMigratedTo = isMigratedTo
    isMigratedToProp = property(getIsmigratedto, setIsmigratedto)
    def getStoragerealisation(self): return self.storageRealisation
    def setStoragerealisation(self, storageRealisation): self.storageRealisation = storageRealisation
    storageRealisationProp = property(getStoragerealisation, setStoragerealisation)
    def validate_storageRealisation(self, value):
        # validate type storageRealisation
        pass
    def getUsername(self): return self.username
    def setUsername(self, username): self.username = username
    usernameProp = property(getUsername, setUsername)
    def getPassword(self): return self.password
    def setPassword(self, password): self.password = password
    passwordProp = property(getPassword, setPassword)
    def getAwsaccesskey(self): return self.awsAccessKey
    def setAwsaccesskey(self, awsAccessKey): self.awsAccessKey = awsAccessKey
    awsAccessKeyProp = property(getAwsaccesskey, setAwsaccesskey)
    def getAwssecretaccesskey(self): return self.awsSecretAccessKey
    def setAwssecretaccesskey(self, awsSecretAccessKey): self.awsSecretAccessKey = awsSecretAccessKey
    awsSecretAccessKeyProp = property(getAwssecretaccesskey, setAwssecretaccesskey)
    def export(self, outfile, level, namespace_='', name_='s3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='s3')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="s3"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='s3'):
        datastore.exportAttributes(self, outfile, level, namespace_, name_='s3')
    def exportChildren(self, outfile, level, namespace_='', name_='s3'):
        datastore.exportChildren(self, outfile, level, namespace_, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('<%sstoreType>%s</%sstoreType>\n' % (namespace_, self.format_string(quote_xml(self.storeType).encode(ExternalEncoding), input_name='storeType'), namespace_))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataLocation>%s</%sdataLocation>\n' % (namespace_, self.format_string(quote_xml(self.dataLocation).encode(ExternalEncoding), input_name='dataLocation'), namespace_))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('<%sremovePathPrefix>%s</%sremovePathPrefix>\n' % (namespace_, self.format_string(quote_xml(self.removePathPrefix).encode(ExternalEncoding), input_name='removePathPrefix'), namespace_))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('<%sisMigratedTo>%s</%sisMigratedTo>\n' % (namespace_, self.format_string(quote_xml(self.isMigratedTo).encode(ExternalEncoding), input_name='isMigratedTo'), namespace_))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('<%sstorageRealisation>%s</%sstorageRealisation>\n' % (namespace_, self.format_string(quote_xml(self.storageRealisation).encode(ExternalEncoding), input_name='storageRealisation'), namespace_))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('<%susername>%s</%susername>\n' % (namespace_, self.format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('<%spassword>%s</%spassword>\n' % (namespace_, self.format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_))
        if self.awsAccessKey is not None:
            showIndent(outfile, level)
            outfile.write('<%sawsAccessKey>%s</%sawsAccessKey>\n' % (namespace_, self.format_string(quote_xml(self.awsAccessKey).encode(ExternalEncoding), input_name='awsAccessKey'), namespace_))
        if self.awsSecretAccessKey is not None:
            showIndent(outfile, level)
            outfile.write('<%sawsSecretAccessKey>%s</%sawsSecretAccessKey>\n' % (namespace_, self.format_string(quote_xml(self.awsSecretAccessKey).encode(ExternalEncoding), input_name='awsSecretAccessKey'), namespace_))
    def hasContent_(self):
        if (
            self.storeType is not None or
            self.dataLocation is not None or
            self.removePathPrefix is not None or
            self.isMigratedTo is not None or
            self.storageRealisation is not None or
            self.username is not None or
            self.password is not None or
            self.awsAccessKey is not None or
            self.awsSecretAccessKey is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='s3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        datastore.exportLiteralAttributes(self, outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        datastore.exportLiteralChildren(self, outfile, level, name_)
        if self.storeType is not None:
            showIndent(outfile, level)
            outfile.write('storeType=%s,\n' % quote_python(self.storeType).encode(ExternalEncoding))
        if self.dataLocation is not None:
            showIndent(outfile, level)
            outfile.write('dataLocation=%s,\n' % quote_python(self.dataLocation).encode(ExternalEncoding))
        if self.removePathPrefix is not None:
            showIndent(outfile, level)
            outfile.write('removePathPrefix=%s,\n' % quote_python(self.removePathPrefix).encode(ExternalEncoding))
        if self.isMigratedTo is not None:
            showIndent(outfile, level)
            outfile.write('isMigratedTo=%s,\n' % quote_python(self.isMigratedTo).encode(ExternalEncoding))
        if self.storageRealisation is not None:
            showIndent(outfile, level)
            outfile.write('storageRealisation=%s,\n' % quote_python(self.storageRealisation).encode(ExternalEncoding))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
        if self.awsAccessKey is not None:
            showIndent(outfile, level)
            outfile.write('awsAccessKey=%s,\n' % quote_python(self.awsAccessKey).encode(ExternalEncoding))
        if self.awsSecretAccessKey is not None:
            showIndent(outfile, level)
            outfile.write('awsSecretAccessKey=%s,\n' % quote_python(self.awsSecretAccessKey).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        datastore.buildAttributes(self, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storeType':
            storeType_ = ''
            for text__content_ in child_.childNodes:
                storeType_ += text__content_.nodeValue
            self.storeType = storeType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataLocation':
            dataLocation_ = ''
            for text__content_ in child_.childNodes:
                dataLocation_ += text__content_.nodeValue
            self.dataLocation = dataLocation_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'removePathPrefix':
            removePathPrefix_ = ''
            for text__content_ in child_.childNodes:
                removePathPrefix_ += text__content_.nodeValue
            self.removePathPrefix = removePathPrefix_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'isMigratedTo':
            isMigratedTo_ = ''
            for text__content_ in child_.childNodes:
                isMigratedTo_ += text__content_.nodeValue
            self.isMigratedTo = isMigratedTo_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'storageRealisation':
            storageRealisation_ = ''
            for text__content_ in child_.childNodes:
                storageRealisation_ += text__content_.nodeValue
            self.storageRealisation = storageRealisation_
            self.validate_storageRealisation(self.storageRealisation)    # validate type storageRealisation
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'username':
            username_ = ''
            for text__content_ in child_.childNodes:
                username_ += text__content_.nodeValue
            self.username = username_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'password':
            password_ = ''
            for text__content_ in child_.childNodes:
                password_ += text__content_.nodeValue
            self.password = password_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'awsAccessKey':
            awsAccessKey_ = ''
            for text__content_ in child_.childNodes:
                awsAccessKey_ += text__content_.nodeValue
            self.awsAccessKey = awsAccessKey_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'awsSecretAccessKey':
            awsSecretAccessKey_ = ''
            for text__content_ in child_.childNodes:
                awsSecretAccessKey_ += text__content_.nodeValue
            self.awsSecretAccessKey = awsSecretAccessKey_
        datastore.buildChildren(self, child_, nodeName_)
# end class s3


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = datastores.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="datastores", 
        namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = datastores.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="datastores",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = datastores.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from datastores import *\n\n')
    sys.stdout.write('import datastores as model_\n\n')
    sys.stdout.write('rootObj = model_.datastores(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_="datastores")
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

