#!/usr/bin/env python

#
# Generated Mon May 10 11:18:10 2010 by generateDS.py version 1.20e.
#

import sys
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class preferences(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, useLdap=False, ldapServerUri='ldap://intra.dlr.de:389/', ldapBaseDn='OU=DLR,DC=intra,DC=dlr,DC=de', connections=None, scriptUris=None, searchQueries=None):
        self.useLdap = useLdap
        self.ldapServerUri = ldapServerUri
        self.ldapBaseDn = ldapBaseDn
        if connections is None:
            self.connections = []
        else:
            self.connections = connections
        if scriptUris is None:
            self.scriptUris = []
        else:
            self.scriptUris = scriptUris
        if searchQueries is None:
            self.searchQueries = []
        else:
            self.searchQueries = searchQueries
    def factory(*args_, **kwargs_):
        if preferences.subclass:
            return preferences.subclass(*args_, **kwargs_)
        else:
            return preferences(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getUseldap(self): return self.useLdap
    def setUseldap(self, useLdap): self.useLdap = useLdap
    useLdapProp = property(getUseldap, setUseldap)
    def getLdapserveruri(self): return self.ldapServerUri
    def setLdapserveruri(self, ldapServerUri): self.ldapServerUri = ldapServerUri
    ldapServerUriProp = property(getLdapserveruri, setLdapserveruri)
    def getLdapbasedn(self): return self.ldapBaseDn
    def setLdapbasedn(self, ldapBaseDn): self.ldapBaseDn = ldapBaseDn
    ldapBaseDnProp = property(getLdapbasedn, setLdapbasedn)
    def getConnections(self): return self.connections
    def setConnections(self, connections): self.connections = connections
    def addConnections(self, value): self.connections.append(value)
    def insertConnections(self, index, value): self.connections[index] = value
    connectionsProp = property(getConnections, setConnections)
    def getScripturis(self): return self.scriptUris
    def setScripturis(self, scriptUris): self.scriptUris = scriptUris
    def addScripturis(self, value): self.scriptUris.append(value)
    def insertScripturis(self, index, value): self.scriptUris[index] = value
    scriptUrisProp = property(getScripturis, setScripturis)
    def getSearchqueries(self): return self.searchQueries
    def setSearchqueries(self, searchQueries): self.searchQueries = searchQueries
    def addSearchqueries(self, value): self.searchQueries.append(value)
    def insertSearchqueries(self, index, value): self.searchQueries[index] = value
    searchQueriesProp = property(getSearchqueries, setSearchqueries)
    def export(self, outfile, level, namespace_='', name_='preferences', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='preferences')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='preferences'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='preferences'):
        if self.useLdap is not None:
            showIndent(outfile, level)
            outfile.write('<%suseLdap>%s</%suseLdap>\n' % (namespace_, self.format_boolean(str_lower(str(self.useLdap)), input_name='useLdap'), namespace_))
        if self.ldapServerUri is not None:
            showIndent(outfile, level)
            outfile.write('<%sldapServerUri>%s</%sldapServerUri>\n' % (namespace_, self.format_string(quote_xml(self.ldapServerUri).encode(ExternalEncoding), input_name='ldapServerUri'), namespace_))
        if self.ldapBaseDn is not None:
            showIndent(outfile, level)
            outfile.write('<%sldapBaseDn>%s</%sldapBaseDn>\n' % (namespace_, self.format_string(quote_xml(self.ldapBaseDn).encode(ExternalEncoding), input_name='ldapBaseDn'), namespace_))
        for connections_ in self.connections:
            connections_.export(outfile, level, namespace_, name_='connections')
        for scriptUris_ in self.scriptUris:
            showIndent(outfile, level)
            outfile.write('<%sscriptUris>%s</%sscriptUris>\n' % (namespace_, self.format_string(quote_xml(scriptUris_).encode(ExternalEncoding), input_name='scriptUris'), namespace_))
        for searchQueries_ in self.searchQueries:
            searchQueries_.export(outfile, level, namespace_, name_='searchQueries')
    def hasContent_(self):
        if (
            self.useLdap is not None or
            self.ldapServerUri is not None or
            self.ldapBaseDn is not None or
            self.connections or
            self.scriptUris or
            self.searchQueries
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='preferences'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.useLdap is not None:
            showIndent(outfile, level)
            outfile.write('useLdap=%s,\n' % self.useLdap)
        if self.ldapServerUri is not None:
            showIndent(outfile, level)
            outfile.write('ldapServerUri=%s,\n' % quote_python(self.ldapServerUri).encode(ExternalEncoding))
        if self.ldapBaseDn is not None:
            showIndent(outfile, level)
            outfile.write('ldapBaseDn=%s,\n' % quote_python(self.ldapBaseDn).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('connections=[\n')
        level += 1
        for connections_ in self.connections:
            showIndent(outfile, level)
            outfile.write('model_.connection(\n')
            connections_.exportLiteral(outfile, level, name_='connection')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('scriptUris=[\n')
        level += 1
        for scriptUris_ in self.scriptUris:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(scriptUris_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('searchQueries=[\n')
        level += 1
        for searchQueries_ in self.searchQueries:
            showIndent(outfile, level)
            outfile.write('model_.searchQuery(\n')
            searchQueries_.exportLiteral(outfile, level, name_='searchQuery')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'useLdap':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.useLdap = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ldapServerUri':
            ldapServerUri_ = ''
            for text__content_ in child_.childNodes:
                ldapServerUri_ += text__content_.nodeValue
            self.ldapServerUri = ldapServerUri_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ldapBaseDn':
            ldapBaseDn_ = ''
            for text__content_ in child_.childNodes:
                ldapBaseDn_ += text__content_.nodeValue
            self.ldapBaseDn = ldapBaseDn_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connections':
            obj_ = connection.factory()
            obj_.build(child_)
            self.connections.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'scriptUris':
            scriptUris_ = ''
            for text__content_ in child_.childNodes:
                scriptUris_ += text__content_.nodeValue
            self.scriptUris.append(scriptUris_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchQueries':
            obj_ = searchQuery.factory()
            obj_.build(child_)
            self.searchQueries.append(obj_)
# end class preferences


class connection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, url=None, username=None, password=None, defaultDataStore=None, defaultArchiveStore=None, defaultOfflineStore=None):
        self.url = url
        self.username = username
        self.password = password
        self.defaultDataStore = defaultDataStore
        self.defaultArchiveStore = defaultArchiveStore
        self.defaultOfflineStore = defaultOfflineStore
    def factory(*args_, **kwargs_):
        if connection.subclass:
            return connection.subclass(*args_, **kwargs_)
        else:
            return connection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getUrl(self): return self.url
    def setUrl(self, url): self.url = url
    urlProp = property(getUrl, setUrl)
    def getUsername(self): return self.username
    def setUsername(self, username): self.username = username
    usernameProp = property(getUsername, setUsername)
    def getPassword(self): return self.password
    def setPassword(self, password): self.password = password
    passwordProp = property(getPassword, setPassword)
    def getDefaultdatastore(self): return self.defaultDataStore
    def setDefaultdatastore(self, defaultDataStore): self.defaultDataStore = defaultDataStore
    defaultDataStoreProp = property(getDefaultdatastore, setDefaultdatastore)
    def getDefaultarchivestore(self): return self.defaultArchiveStore
    def setDefaultarchivestore(self, defaultArchiveStore): self.defaultArchiveStore = defaultArchiveStore
    defaultArchiveStoreProp = property(getDefaultarchivestore, setDefaultarchivestore)
    def getDefaultofflinestore(self): return self.defaultOfflineStore
    def setDefaultofflinestore(self, defaultOfflineStore): self.defaultOfflineStore = defaultOfflineStore
    defaultOfflineStoreProp = property(getDefaultofflinestore, setDefaultofflinestore)
    def export(self, outfile, level, namespace_='', name_='connection', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='connection')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connection'):
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('<%surl>%s</%surl>\n' % (namespace_, self.format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('<%susername>%s</%susername>\n' % (namespace_, self.format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('<%spassword>%s</%spassword>\n' % (namespace_, self.format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_))
        if self.defaultDataStore is not None:
            showIndent(outfile, level)
            outfile.write('<%sdefaultDataStore>%s</%sdefaultDataStore>\n' % (namespace_, self.format_string(quote_xml(self.defaultDataStore).encode(ExternalEncoding), input_name='defaultDataStore'), namespace_))
        if self.defaultArchiveStore is not None:
            showIndent(outfile, level)
            outfile.write('<%sdefaultArchiveStore>%s</%sdefaultArchiveStore>\n' % (namespace_, self.format_string(quote_xml(self.defaultArchiveStore).encode(ExternalEncoding), input_name='defaultArchiveStore'), namespace_))
        if self.defaultOfflineStore is not None:
            showIndent(outfile, level)
            outfile.write('<%sdefaultOfflineStore>%s</%sdefaultOfflineStore>\n' % (namespace_, self.format_string(quote_xml(self.defaultOfflineStore).encode(ExternalEncoding), input_name='defaultOfflineStore'), namespace_))
    def hasContent_(self):
        if (
            self.url is not None or
            self.username is not None or
            self.password is not None or
            self.defaultDataStore is not None or
            self.defaultArchiveStore is not None or
            self.defaultOfflineStore is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
        if self.defaultDataStore is not None:
            showIndent(outfile, level)
            outfile.write('defaultDataStore=%s,\n' % quote_python(self.defaultDataStore).encode(ExternalEncoding))
        if self.defaultArchiveStore is not None:
            showIndent(outfile, level)
            outfile.write('defaultArchiveStore=%s,\n' % quote_python(self.defaultArchiveStore).encode(ExternalEncoding))
        if self.defaultOfflineStore is not None:
            showIndent(outfile, level)
            outfile.write('defaultOfflineStore=%s,\n' % quote_python(self.defaultOfflineStore).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'url':
            url_ = ''
            for text__content_ in child_.childNodes:
                url_ += text__content_.nodeValue
            self.url = url_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'username':
            username_ = ''
            for text__content_ in child_.childNodes:
                username_ += text__content_.nodeValue
            self.username = username_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'password':
            password_ = ''
            for text__content_ in child_.childNodes:
                password_ += text__content_.nodeValue
            self.password = password_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'defaultDataStore':
            defaultDataStore_ = ''
            for text__content_ in child_.childNodes:
                defaultDataStore_ += text__content_.nodeValue
            self.defaultDataStore = defaultDataStore_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'defaultArchiveStore':
            defaultArchiveStore_ = ''
            for text__content_ in child_.childNodes:
                defaultArchiveStore_ += text__content_.nodeValue
            self.defaultArchiveStore = defaultArchiveStore_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'defaultOfflineStore':
            defaultOfflineStore_ = ''
            for text__content_ in child_.childNodes:
                defaultOfflineStore_ += text__content_.nodeValue
            self.defaultOfflineStore = defaultOfflineStore_
# end class connection


class searchQuery(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, query=None):
        self.name = name
        self.query = query
    def factory(*args_, **kwargs_):
        if searchQuery.subclass:
            return searchQuery.subclass(*args_, **kwargs_)
        else:
            return searchQuery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getName(self): return self.name
    def setName(self, name): self.name = name
    nameProp = property(getName, setName)
    def getQuery(self): return self.query
    def setQuery(self, query): self.query = query
    queryProp = property(getQuery, setQuery)
    def export(self, outfile, level, namespace_='', name_='searchQuery', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='searchQuery')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='searchQuery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='searchQuery'):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.query is not None:
            showIndent(outfile, level)
            outfile.write('<%squery>%s</%squery>\n' % (namespace_, self.format_string(quote_xml(self.query).encode(ExternalEncoding), input_name='query'), namespace_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.query is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='searchQuery'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.query is not None:
            showIndent(outfile, level)
            outfile.write('query=%s,\n' % quote_python(self.query).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'name':
            name_ = ''
            for text__content_ in child_.childNodes:
                name_ += text__content_.nodeValue
            self.name = name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'query':
            query_ = ''
            for text__content_ in child_.childNodes:
                query_ += text__content_.nodeValue
            self.query = query_
# end class searchQuery


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = preferences.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="preferences", 
        namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = preferences.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="preferences",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = preferences.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from preferences import *\n\n')
    sys.stdout.write('import preferences as model_\n\n')
    sys.stdout.write('rootObj = model_.preferences(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_="preferences")
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

